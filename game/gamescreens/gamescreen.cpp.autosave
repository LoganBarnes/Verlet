#include "gamescreen.h"
#include "application.h"
#include "actioncamera.h"
#include "player.h"
#include "geometriccollisionmanager.h"
#include "triangle.h"

GameScreen::GameScreen(Application *parent, int laps)
    : Screen(parent)
{
    m_parentApp->setUseCubeMap(false);

    m_oh = new ObjectHandler();

    ActionCamera *cam = new ActionCamera();
    glm::vec3 playerPos = glm::vec3(0, 2, 0);
    cam->setCenter(playerPos);

    GamePlayer player = new GamePlayer(cam, playerPos);

    m_world = new GameWorld();
    m_world->addManager(gcm);
    m_world->setPlayer(player);
//    m_world->setGravity(glm::vec3(0, -10, 0));

    setCamera(cam);
}

GameScreen::~GameScreen()
{
    delete m_oh;
    delete m_world;
}

// update and render
void GameScreen::onTick(float secs  )
{
    m_world->onTick(secs);
}

void GameScreen::onRender(Graphics *g)
{

}

void GameScreen::render2D(Graphics *g)
{
    glm::mat4 trans;
    glm::vec4 look = m_camera->getLook();
    glm::vec3 pos = m_player->getPosition();
    glm::vec3 wp = m_player->getCurrentWaypoint();

    g->setGraphicsMode(DRAW2D);
    g->setTexture("");

    // no waypoints set
    if (glm::dot(wp, wp) < 0.0001f)
        return;

    glm::vec4 p = m_camera->getProjectionMatrix() *
            m_camera->getViewMatrix() * glm::vec4(wp, 1);

    p /= p.w;
    // check if waypoint is within frustum
    if (p.z >= 0 && p.z <= 1 && p.x >= -1 && p.x <= 1 && p.y >= -1 && p.y <= 1)
        return;


    glm::vec2 vec = glm::vec2(wp.x - pos.x, wp.z - pos.z);
    vec = glm::normalize(vec);
    glm::vec2 up = glm::normalize(glm::vec2(look.x, look.z));

    float dot = glm::dot(up, vec);
    float det = up.x*vec.y - up.y*vec.x;
    float angle = std::atan2(det, dot);
    trans = glm::rotate(glm::mat4(), -angle, glm::vec3(0, 0, 1));
    trans *= glm::translate(glm::mat4(), glm::vec3(0, .9f, 0));
    trans *= glm::scale(glm::mat4(), glm::vec3(.05f));

    g->drawCone(trans);
}


void GameScreen::onMouseMoved(QMouseEvent *e, float deltaX, float deltaY)
{
    if (m_startTimer < 0.f && m_outcome == 0)
        m_world->onMouseMoved(e, deltaX, deltaY);
}
void GameScreen::onKeyReleased(QKeyEvent *e )
{
    if (e->key() == Qt::Key_N)
        m_drawNavMesh = !m_drawNavMesh;
    else if (e->key() == Qt::Key_G)
        m_graphicsCardDestructionMode = !m_graphicsCardDestructionMode;

    m_world->onKeyReleased(e);
}
void GameScreen::onMouseDragged(QMouseEvent *e, float deltaX, float deltaY)
{
    if (m_startTimer < 0.f && m_outcome == 0)
        m_world->onMouseMoved(e, deltaX, deltaY);
}

void GameScreen::onKeyPressed(QKeyEvent *e)
{
    if (m_outcome > 0)
    {
        switch (e->key())
        {
        case Qt::Key_W:
        case Qt::Key_A:
        case Qt::Key_S:
        case Qt::Key_D:
        case Qt::Key_G:
        case Qt::Key_N:
            break;
        default:
            m_parentApp->popScreens(1);
            break;
        }
        return;
    }

    switch (e->key())
    {
    case Qt::Key_Back:
    case Qt::Key_Backspace:
    case Qt::Key_Delete:
        m_parentApp->popScreens(1);
        break;
    default:
        if (m_startTimer < 0.f && m_outcome == 0)
            m_world->onKeyPressed(e);
        break;
    }
}


// unused in game
void GameScreen::onMousePressed(QMouseEvent *) {}
void GameScreen::onMouseReleased(QMouseEvent *) {}
void GameScreen::onMouseWheel(QWheelEvent *) {}
